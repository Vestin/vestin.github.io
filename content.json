{"meta":{"title":"horizon","subtitle":"Vestin's blog","description":null,"author":"Vestin","url":"http://vestin.github.io"},"pages":[{"title":"about","date":"2017-10-19T09:22:59.000Z","updated":"2017-10-19T09:44:47.661Z","comments":true,"path":"about/index.html","permalink":"http://vestin.github.io/about/index.html","excerpt":"","text":"@card{ for freedom!!! contact: email: vestinzds@gmail.comsegmentfault: https://segmentfault.com/u/vestinwechat: vestin }"},{"title":"","date":"2017-10-19T08:55:11.977Z","updated":"2017-10-19T08:55:11.969Z","comments":false,"path":"categories/index.html","permalink":"http://vestin.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-19T08:29:26.476Z","updated":"2017-10-19T08:29:26.468Z","comments":false,"path":"tags/index.html","permalink":"http://vestin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"测试laravel commands的方法","slug":"test-laravel-artisan-command","date":"2017-10-27T09:21:41.000Z","updated":"2017-10-28T07:23:28.616Z","comments":true,"path":"2017/10/27/test-laravel-artisan-command/","link":"","permalink":"http://vestin.github.io/2017/10/27/test-laravel-artisan-command/","excerpt":"引言最近使用到laravel的consolo命令行工具，在编写命令，想写一些测试的时候，发现官方文档中并没有提到command的测试方法。花了点时间，翻墙找了资料，实践成功并记录一下，方便更多人。","text":"引言最近使用到laravel的consolo命令行工具，在编写命令，想写一些测试的时候，发现官方文档中并没有提到command的测试方法。花了点时间，翻墙找了资料，实践成功并记录一下，方便更多人。 测试方法大家都知道Laravel中使用了很多Symfony的成熟组件，Laravel的console组件使用的就是Symfony/console。 幸运的是，Symfony/console 组件中提供了用于command测试的CommandTester, 使用方法如下123456789101112131415161718192021222324252627282930313233...use FooCommand;use Symfony\\Component\\Console\\Application;use Symfony\\Component\\Console\\Tester\\CommandTester;...public function testSample()&#123; //创建一个console测试应用平台，用来搭载测试的命令 $application = new Application(); //创建待测试的command $testedCommand = $this-&gt;app-&gt;make(FooCommand::class); //设置命令执行需要的laravel依赖 $testedCommand-&gt;setLaravel(app()); //添加待测试的command到测试应用上 //同时command 也绑定 application $application-&gt;add($testedCommand); //实例化命令测试类 $commandTester = new CommandTester($testedCommand); //命令输入流，对应每次交互需要提供的输入内容 $commandTester-&gt;setInputs([ //... ]); //执行命令 $commandTester-&gt;execute([&apos;command&apos; =&gt; $testedCommand-&gt;getName()]); //对命令执行结果进行断言测试，主要是依靠正则判断 //$commandTester-&gt;getDisplay() 方法可以获取命令执行后的输出结果 $this-&gt;assertRegExp(&quot;/some reg/&quot;, $commandTester-&gt;getDisplay());&#125; 示例我们现在有一个手动创建新用户的命令createUser,作用就是手动创建一个用户。 需要交互式让用户输入name,email,password,comfirm password,这些数据。 待测试的command123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?phpnamespace App\\Console\\Commands;use App\\User;use Illuminate\\Auth\\Events\\Registered;use Illuminate\\Console\\Command;use Illuminate\\Support\\Facades\\Validator;class CreateUser extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = &apos;createUser&apos;; /** * The console command description. * * @var string */ protected $description = &apos;create new user for system manually&apos;; /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $this-&gt;line($this-&gt;description); // 获取输入的数据 $data = [ &apos;name&apos; =&gt; $this-&gt;ask(&apos;What\\&apos;s your name?&apos;), &apos;email&apos; =&gt; $this-&gt;ask(&apos;What\\&apos;s your email?&apos;), &apos;password&apos; =&gt; $this-&gt;secret(&apos;What\\&apos;s your password?&apos;), &apos;password_confirmation&apos; =&gt; $this-&gt;secret(&apos;Pleas confirm your password.&apos;) ]; // 验证输入内容 $validator = $this-&gt;makeValidator($data); if ($validator-&gt;fails()) &#123; foreach ($validator-&gt;errors()-&gt;toArray() as $error) &#123; foreach ($error as $message) &#123; $this-&gt;error($message); &#125; &#125; return; &#125; // 向用户确认输入信息 if (!$this-&gt;confirm(&apos;Confirm your info: &apos; . PHP_EOL . &apos;name:&apos; . $data[&apos;name&apos;] . PHP_EOL . &apos;email:&apos; . $data[&apos;email&apos;] . PHP_EOL . &apos;is this correct?&apos;)) &#123; return; &#125; // 注册 $user = $this-&gt;create($data); event(new Registered($user)); $this-&gt;line(&apos;User &apos; . $user-&gt;name . &apos; successfully registered&apos;); &#125; /** * Get a validator for an incoming registration request. * * @param array $data * @return \\Illuminate\\Contracts\\Validation\\Validator */ protected function makeValidator($data) &#123; return Validator::make($data, [ &apos;name&apos; =&gt; &apos;required|string|max:255|unique:users&apos;, &apos;email&apos; =&gt; &apos;required|string|email|max:255|unique:users&apos;, &apos;password&apos; =&gt; &apos;required|string|min:6|confirmed&apos; ]); &#125; /** * Create a new user instance after a valid registration. * * @param array $data * @return \\App\\User */ protected function create($data) &#123; return User::create([ &apos;name&apos; =&gt; $data[&apos;name&apos;], &apos;email&apos; =&gt; $data[&apos;email&apos;], &apos;password&apos; =&gt; bcrypt($data[&apos;password&apos;]) ]); &#125;&#125; 正确的结果如果正确输入信息的话，会得到如下输出12345678910111213141516171819202122$ path-to-your-app/app# php artisan createUsercreate new user for system manually What&apos;s your name?: &gt; vestin What&apos;s your email?: &gt; correct@abc.com What&apos;s your password?: &gt; Pleas confirm your password.: &gt; Confirm your info: name:vestinemail:correct@abc.comis this correct? (yes/no) [no]: &gt; yesUser vestin successfully registered 想要测试的内容我想要测试两块内容： 数据输入验证测试 email有效性测试 password两次输入是否相同的测试 正确创建用户测试 编写单元测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpnamespace Tests\\Unit\\command;use App\\Console\\Commands\\CreateUser;use Symfony\\Component\\Console\\Application;use Symfony\\Component\\Console\\Tester\\CommandTester;use Tests\\TestCase;use Illuminate\\Foundation\\Testing\\RefreshDatabase;class CreateUserTest extends TestCase&#123; use RefreshDatabase; /** * 测试数据验证 * * @return void */ public function testValidation() &#123; $application = new Application(); $testedCommand = $this-&gt;app-&gt;make(CreateUser::class); $testedCommand-&gt;setLaravel(app()); $application-&gt;add($testedCommand); $commandTester = new CommandTester($testedCommand); $commandTester-&gt;setInputs([&apos;Vestin&apos;, &apos;badEmail@abc&apos;, &apos;123456&apos;, &apos;654321&apos;]); $commandTester-&gt;execute([&apos;command&apos; =&gt; $testedCommand-&gt;getName()]); // assert $this-&gt;assertRegExp(&quot;/The email must be a valid email address/&quot;, $commandTester-&gt;getDisplay()); $commandTester-&gt;setInputs([&apos;vestin&apos;, &apos;correct@abc.com&apos;, &apos;123456&apos;, &apos;654321&apos;]); $commandTester-&gt;execute([&apos;command&apos; =&gt; $testedCommand-&gt;getName()]); // assert $this-&gt;assertRegExp(&quot;/The password confirmation does not match/&quot;, $commandTester-&gt;getDisplay()); &#125; /** * 测试成功注册用户 * * @return void */ public function testSuccess() &#123; $application = new Application(); $testedCommand = $this-&gt;app-&gt;make(CreateUser::class); $testedCommand-&gt;setLaravel(app()); $application-&gt;add($testedCommand); $commandTester = new CommandTester($testedCommand); $commandTester-&gt;setInputs([&apos;Vestin&apos;, &apos;correct@abc.com&apos;, &apos;123456&apos;, &apos;123456&apos;, &apos;y&apos;]); $commandTester-&gt;execute([&apos;command&apos; =&gt; $testedCommand-&gt;getName()]); // assert $this-&gt;assertRegExp(&quot;/User Vestin successfully registered/&quot;, $commandTester-&gt;getDisplay()); $this-&gt;assertDatabaseHas(&apos;users&apos;, [ &apos;email&apos; =&gt; &apos;correct@abc.com&apos;, &apos;name&apos; =&gt; &apos;Vestin&apos; ]); &#125;&#125; 执行测试123456$ path-to-your-app/app# ./vendor/bin/phpunit PHPUnit 6.4.3 by Sebastian Bergmann and contributors... 3 / 3 (100%)Time: 659 ms, Memory: 14.00MB 参考文档 http://symfony.com/doc/current/components/console.html https://laracasts.com/discuss/channels/testing/how-do-you-test-your-commands-phpunit https://themsaid.com/building-testing-interactive-console-20160409 https://laravelista.com/posts/testing-laravel-commands","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://vestin.github.io/tags/tools/"},{"name":"laravel","slug":"laravel","permalink":"http://vestin.github.io/tags/laravel/"},{"name":"test","slug":"test","permalink":"http://vestin.github.io/tags/test/"}]},{"title":"Larvel 开发中使用顺手的一些工具集","slug":"develop-tools-in-laravel","date":"2017-10-25T07:34:54.000Z","updated":"2017-10-25T08:12:17.047Z","comments":true,"path":"2017/10/25/develop-tools-in-laravel/","link":"","permalink":"http://vestin.github.io/2017/10/25/develop-tools-in-laravel/","excerpt":"开发项目较多，使用到很多工具，记录下来，方便使用。 Larvel 开发中使用顺手的一些工具集 ide-helper","text":"开发项目较多，使用到很多工具，记录下来，方便使用。 Larvel 开发中使用顺手的一些工具集 ide-helper ide-helperLaravel中大量使用facade,使IDE识别困难,配合Phpstorm的Laravel Plugin插件使用，效果完美。 laravel依赖包 ide-helper Phpstorm插件 laravel Plugin 常用命令12345//生成辅助文件php artisan ide-helper:generate//生成model的phpdocphp artisan ide-helper:models","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://vestin.github.io/tags/tools/"},{"name":"laravel","slug":"laravel","permalink":"http://vestin.github.io/tags/laravel/"}]},{"title":"php hook 机制&原理&实现","slug":"php-hook","date":"2017-04-08T02:30:00.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2017/04/08/php-hook/","link":"","permalink":"http://vestin.github.io/2017/04/08/php-hook/","excerpt":"","text":"Understanding the Shopware hook system Hooks and Events What should plugins use: hooks, events or something else?","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[]},{"title":"design-pattern-template-pattern","slug":"design-pattern-template-pattern","date":"2016-07-03T16:00:00.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/07/04/design-pattern-template-pattern/","link":"","permalink":"http://vestin.github.io/2016/07/04/design-pattern-template-pattern/","excerpt":"Template Pattern定义一个操作中算法的骨架，而将一些步骤延迟到子类中，在不改变算法结果的情况下重新定义它的步骤。","text":"Template Pattern定义一个操作中算法的骨架，而将一些步骤延迟到子类中，在不改变算法结果的情况下重新定义它的步骤。 与strategy模式的区别:Template Method 模式 适用于存在几个概念上相似，但不相同的过程。每个过程都是互相耦合的，因为他们与某个过程相关。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpAbstract Class Calculate&#123; public $a; public $b; public function __construct($a,$b)&#123; $this-&gt;a = $a; $this-&gt;b = $b; &#125; public function run()&#123; $resA = $this-&gt;calculateA($this-&gt;a); $resB = $this-&gt;calculateB($this-&gt;b); return $resA+$resB; &#125; abstract public function calculateA($a); abstract public function calculateB($b);&#125;Class AddCalculate extends Calculate&#123; public function calculateA($a)&#123; return $a+$a; &#125; public function calculateB($b)&#123; return $b+$b; &#125;&#125;Class PlusCaculate extends Calculate&#123; public function calculateA($a)&#123; return $a*$a; &#125; public function calculateB($b)&#123; return $b*$b; &#125;&#125;//testecho (new AddCalculate(1,2))-&gt;run(); //6echo PHP_EOL;echo (new PlusCaculate(1,2))-&gt;run(); //5echo PHP_EOL;","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"design-pattern-commonality-and-variability-analysis","slug":"design-pattern-CVA","date":"2016-06-17T01:48:53.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/06/17/design-pattern-CVA/","link":"","permalink":"http://vestin.github.io/2016/06/17/design-pattern-CVA/","excerpt":"commonality and variability analysis (CVA) 共性可变性分析共性可变性分析 设计模式不能用于所有的设计中，但他们提供的思想是相同的。这些思想中，最重要的一条就是可以使用CVA找到系统中的变化，然后按照设计模式的原则（对接口编程、使用对象聚集封装变化）获得灵活和易于测试的设计。","text":"commonality and variability analysis (CVA) 共性可变性分析共性可变性分析 设计模式不能用于所有的设计中，但他们提供的思想是相同的。这些思想中，最重要的一条就是可以使用CVA找到系统中的变化，然后按照设计模式的原则（对接口编程、使用对象聚集封装变化）获得灵活和易于测试的设计。 造成紧耦合程序设计的原因就是** 开发人员经常在弄清楚实体本身之前就考虑实体之间的关系**，过早得注意实现细节。 首先，使用CVA找到问题领域中存在的各种概念（共性）和具体的实现（可变性）。这时我们最感兴趣的是找到其中的概念，但是这一过程中也会发现许多可变性。问题域中任何没有包含在这些概念中的实体（比如可能有一些属于“某种”对象的对象）也应该找出来。然后，在所需功能的概念全部找到之后，继续为封装这些概念的抽象定制接口。接着考虑你将如何使用从该抽象派生的具体实现，根据这一点派生接口。 CVA方法和设计模式的区别是： CVA强调尽早关注抽象，这样更可能找到最有用的抽象。设计模式关注这些抽象之间的关系，但是对于找出最重要的抽象帮助不大。设计模式可以使我们利用来自过去成功设计的真知灼见，而CVA做不到这一点。 分析得到共性和可变性之后，就自然可以形成若干独立的模型（继承结构）。下步任务是确定概念之间的关系。这个过程中，设计模式会对确定概念间关系有指导作用，但不是决定作用。概念间的关系还是要有问题本身来决定，这样才能得到符合真实世界情况的关系模型，在此基础上，设计模式会帮助优化该模式。 要指出的是，CVA和经典的“名词动词分析法”并不相悖。名词动词分析法中，程序员提取需求描述中的名词和动词，由此来确定系统中的对象及其行为。CVA方法在此基础上更进了一步，在得到具体事物之后要求提取出事物间的共性，也就是概念，以此作为抽象接口的设计蓝图。如果在初始阶段就作如此分析，那么设计过程基本上就满足了“依赖倒置”原则。最终得到的设计也会具有一定的灵活性（但并不能保证这一点，毕竟左右设计结果的因素很多）。 参考设计模式解析笔记 - 共性和可变性分析","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"design-pattern-adapter-pattern","slug":"design-pattern-adapter-pattern","date":"2016-06-17T01:48:53.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/06/17/design-pattern-adapter-pattern/","link":"","permalink":"http://vestin.github.io/2016/06/17/design-pattern-adapter-pattern/","excerpt":"Adapter Pattern在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。Adapter设计模式就是为了应对这种“迁移的变化”，以使客户系统既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口。","text":"Adapter Pattern在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。Adapter设计模式就是为了应对这种“迁移的变化”，以使客户系统既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php//原运输系统 和 车辆Class Transport&#123; private $car; //运输的车辆 public function __construct(Car $car)&#123; $this-&gt;car = $car; &#125; public function transporting()&#123; $this-&gt;car-&gt;run(); &#125;&#125;//车interface Car&#123; //搞运输 public function run();&#125;//正常运输车Class Jeep implements Car&#123; public function run()&#123; echo &apos;run...&apos;; &#125;&#125;//正常情况是这样的$jeep = new Jeep;$transport = new Transport($jeep);$transport-&gt;transporting(); //&apos;run...&apos;;//但有一种车辆，他是这样的Class BMW &#123; public function move()&#123; echo &apos;move...&apos;; &#125;&#125;//BMW 如果想加入运输系统，就需要adapter 模式Class BMWCaradapter implements Car&#123; private $bmw; public function __construct($bmw)&#123; $this-&gt;bmw = $bmw; &#125; public function run()&#123; $bmw-&gt;move(); &#125;&#125;//运行$bmw = new BMW;$BMWCarAdapter = new BMWCarAdapter($bmw);$transport = new Transport($BMWCarAdapter);$transport-&gt;transporting(); //&apos;move...&apos;;//这样就完成了适配","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"产品的方法论","slug":"产品的方法论","date":"2016-05-07T06:34:35.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/05/07/产品的方法论/","link":"","permalink":"http://vestin.github.io/2016/05/07/产品的方法论/","excerpt":"产品的方法论发现问题-&gt;分析问题-&gt;解决问题-&gt;验证问题 –&gt;(继续重发发现问题-&gt;…)","text":"产品的方法论发现问题-&gt;分析问题-&gt;解决问题-&gt;验证问题 –&gt;(继续重发发现问题-&gt;…) 发现问题用户自己不是典型用户时，挖掘用户需求时，不要从自己的想法出发。空想没用，最好要自己尝试使用。 没有好用的办法挖掘时，用户反馈是非常重要的渠道。 经常去了解用户 数据注意的点：听用户的反馈，要非常具体的去了解用户的反馈，而不是非常宽泛的感受，如‘体验不好’,‘效果不好’等。 如果遇到用户反馈说感受不好等宽泛感受时，问问什么。具体去挖掘。 挖掘到问题，要具体思考，不要做传话筒。 从数据看用户画像。 其他：竞品 分析问题用户的问题都是问题，可以拖延处理（排优先级等)，但不能否认问题。 排优先级： 影响用户的规模，覆盖用户面广 通过数据。（没数据怎么办？）太多也不好，大家能达成共识就好。 讨论时不用主观的看法，用客观的数据说话。大家讨论时不用形容词，比如 事情很严重， 影响用户量很大 等等 解决问题解决方案的提出，解决方法至少要提出3套。 解决了问题之后，最重要的是学习到经验。对用户的了解更多。使得自己对用户的了解更多，设计出的产品更好。 找到问题的关键点。 验证问题产品上线不是结束，要明白解决问题的标准是什么？ 数据说话 用户反馈所以看结果时要设定目标 DataReview 产品上线有没有对副作用 有没有效果 设定目标，设定预期（预期没法判断？ 你要努力让自己的预期变准确，你自己要努力让你自己的产品达到预期。多尝试几次，预期会变准确）","categories":[],"tags":[{"name":"产品","slug":"产品","permalink":"http://vestin.github.io/tags/产品/"}]},{"title":"livereload","slug":"livereload","date":"2016-05-06T06:24:57.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/05/06/livereload/","link":"","permalink":"http://vestin.github.io/2016/05/06/livereload/","excerpt":"","text":"nodejs + chrome extension install chrome extension - livereload sudo npm i livereload -g 全局安装node插件livereload, livereload插件详情 在正在修改的html文件中添加 1234&lt;script&gt; document.write(&apos;&lt;script src=&quot;http://&apos; + (location.host || &apos;localhost&apos;).split(&apos;:&apos;)[0] + &apos;:35729/livereload.js?snipver=1&quot;&gt;&lt;/&apos; + &apos;script&gt;&apos;)&lt;/script&gt; 在要修改的文件目录下, 输入命令 12vestin@vestin:~/test$ livereloadStarting LiveReload v0.4.1 for ~/test/mail.html on port 35729. 直接打开html文件，file:///协议就ok 编辑文件，查看结果","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"http://vestin.github.io/tags/tools/"}]},{"title":"sass 2 css gulp workflow,minify html,minify css","slug":"sass-node-gulp","date":"2016-05-04T11:34:59.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/05/04/sass-node-gulp/","link":"","permalink":"http://vestin.github.io/2016/05/04/sass-node-gulp/","excerpt":"目前sass提供了观察文件变化，自动将sass文件编译成css的功能。如：You can also tell Sass to watch the file and update the CSS every time the Sass file changes:sass --watch input.scss:output.cssIf you have a directory with many Sass files, you can also tell Sass to watch the entire directory:sass --watch app/sass:public/stylesheets在有些机子上跟踪编译非常慢。使用不便。如果想更顺手的完成更复杂的编译，就需要使用nodejs,gulp 工具进行处理。 [TOC] 用到的Gulp插件 gulp-sass gulp-clean-css gulp-htmlmin Sass安装环境ubuntu 16.04 sudo apt-get install ruby sudo gem install sass","text":"目前sass提供了观察文件变化，自动将sass文件编译成css的功能。如：You can also tell Sass to watch the file and update the CSS every time the Sass file changes:sass --watch input.scss:output.cssIf you have a directory with many Sass files, you can also tell Sass to watch the entire directory:sass --watch app/sass:public/stylesheets在有些机子上跟踪编译非常慢。使用不便。如果想更顺手的完成更复杂的编译，就需要使用nodejs,gulp 工具进行处理。 [TOC] 用到的Gulp插件 gulp-sass gulp-clean-css gulp-htmlmin Sass安装环境ubuntu 16.04 sudo apt-get install ruby sudo gem install sass 国内会报错，如下123sudo gem install sassERROR: While executing gem ... (Gem::RemoteFetcher::FetchError)Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://api.rubygems.org/quick/Marshal.4.8/sass-3.4.22.gemspec.rz) 原因是国内和谐gem，解决方法是使用淘宝镜像如下12345$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org 重新执行sudo gem install sass nodejs安装安装参考nodejs.orgnpm访问慢的问题参考npm.taobao.org淘宝镜像 gulp安装 gulp 介绍gulpjs.comgulp中文网 gulp 安装参考gulp入门指南简易步骤：在项目更目录执行npm install --save-dev gulp安装gulp-sass插件,详细说明gulp-sassnpm install gulp-sass sass 转 css 操作流示例项目目录结构1234567-node_modules //node 模块-scss //编译前的scss文件 --test.scss-css //编译后的css文件 --test.css--gulpfile.js //gulp任务执行工具配置文件--index.html gulpfile.js文件内容123456789101112var gulp = require(&apos;gulp&apos;);var sass = require(&apos;gulp-sass&apos;);gulp.task(&apos;scss&apos;,function()&#123; gulp.src(&apos;./scss/*.scss&apos;) //这里是scss文件的目录 .pipe(sass().on(&apos;error&apos;,sass.logError)) .pipe(gulp.dest(&apos;./css&apos;)); //这里是编译后css存放的目录&#125;)gulp.task(&apos;default&apos;,function()&#123; gulp.watch(&apos;./scss/*.scss&apos;,[&apos;scss&apos;]); //在这里执行文件观察任务，发现变化执行上面定义好的 `scss`编译任务。&#125;) 启动：node_modules/.bin/gulp gulpfile.js提示123[19:05:18] Using gulpfile ~/test/gulpfile.js[19:05:18] Starting &apos;default&apos;...[19:05:18] Finished &apos;default&apos; after 20 ms 打开编辑器编辑scss下test.scss文件，保存，查看css下test.css文件，已经编译好了。 css 压缩安装 npm i gulp-clean-css --save-dev12345678var gulp = require(&apos;gulp&apos;);var cleanCss = require(&apos;gulp-clean-css&apos;);gulp.task(&apos;minify-css&apos;,function()&#123; gulp.src(&apos;./css/*.css&apos;) .pipe(cleanCSS()) .pipe(gulp.dest(&apos;./mincss/&apos;)); &#125;) 使用 gulp minify-css html 压缩安装 npm i gulp-htmlmin --save-dev12345678var gulp = require(&apos;gulp&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);gulp.task(&apos;htmlmin&apos;,function()&#123; gulp.src(&apos;./*.html&apos;) .pipe(htmlmin(&#123;collapseWhitespace:true&#125;)) .pipe(gulp.dest(&apos;./minhtml/&apos;)); &#125;) 使用 gulp htmlmin","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"http://vestin.github.io/tags/tools/"}]},{"title":"bridge pattern 桥接模式","slug":"bridge-pattern","date":"2016-04-28T03:03:38.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/28/bridge-pattern/","link":"","permalink":"http://vestin.github.io/2016/04/28/bridge-pattern/","excerpt":"桥接模式(bridge pattern)将抽象和实现解耦，使得二者可以独立地变化。一般用在两个或多个维度（抽象）的变化。","text":"桥接模式(bridge pattern)将抽象和实现解耦，使得二者可以独立地变化。一般用在两个或多个维度（抽象）的变化。 bridge 例如：抽象1：Road 具体（高速公路，乡村公路)抽象2：Car 具体（Jeep,BMW)Jeep 可以在告诉公路上跑，也可以在乡村公路上跑，同样BMW也可以。 实现例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpAbstract Road&#123; /** * 在路上跑 /* Abstract function onRoad();&#125;Class SpeedRoad extends Road()&#123; public function onRoad()&#123; echo &apos;在高速公路上&apos;; &#125;&#125;Class CountryRoad extends Road()&#123; public function onRoad()&#123; echo &apos;在乡村公路上&apos;; &#125;&#125;Abstract Car&#123; public $road; //车可以跑 Abstract function run();&#125;Class Jeep extends Car&#123; public function run()&#123; echo &apos;Jepp 跑&apos;; $this-&gt;road-&gt;onRoad(); &#125;&#125;Class BMW extends Car&#123; public function run()&#123; echo &apos;BMW 跑&apos;; $this-&gt;road-&gt;onRoad(); &#125;&#125;//test$speedRoad = new SpeedRoad;$countryRoad = new CountryRoad;$Jeep = new Jeep();$Jeep-&gt;road = $speedRoad;$Jeep-&gt;run(); //Jepp 跑在高速公路上$jeep-&gt;road = $countryRoad;$jeep-&gt;run(); //Jepp 跑在乡村公路上$Bmw = new BMW;$Bmw-&gt;road = $speedRoad;$Bmw-&gt;run(); //BMW 跑在高速公路上$Bmw-&gt;road = $countryRoad;$Bmw-&gt;run(); //BMW 跑在乡村公路上","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"google fonts 国内使用解决方案","slug":"google-fonts-use-in-china","date":"2016-04-26T02:47:01.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/26/google-fonts-use-in-china/","link":"","permalink":"http://vestin.github.io/2016/04/26/google-fonts-use-in-china/","excerpt":"由于众所周知的原因，国内使用google font库有很大的问题。 解决方案1：使用国内镜像如360网站卫士常用前端公共库CDN服务 优点：使用方便 缺点：目标用户包含国外的开发者，不清楚国外用户的加载速度 解决方案2：提供另外一种解决方案，可以自主决定资源下载源，自主配置cdn等服务。","text":"由于众所周知的原因，国内使用google font库有很大的问题。 解决方案1：使用国内镜像如360网站卫士常用前端公共库CDN服务 优点：使用方便 缺点：目标用户包含国外的开发者，不清楚国外用户的加载速度 解决方案2：提供另外一种解决方案，可以自主决定资源下载源，自主配置cdn等服务。 在google fonts 官网上选择字体并获取css链接，如下 1&lt;link href=&apos;https://fonts.googleapis.com/css?family=Oswald&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; 将链接内容下载到本地保存，打开，内容如下： 1234567891011/* latin */@font-face &#123; font-family: &apos;Oswald&apos;; font-style: normal; font-weight: 400; src: local(&apos;Oswald Regular&apos;), local(&apos;Oswald-Regular&apos;), url(https://fonts.gstatic.com/s/oswald/v10/pEobIV_lL25TKBpqVI_a2w.woff2) format(&apos;woff2&apos;); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;&#125;/* 如下可能还有更多代码，但结构是和上面的一样的 */ 将 @font-face 下 src属性下 url 处的文件下载到本地并保存，并将 url 地址修改成本地地址 引用修改后的本地google fonts css文件,就可以使用了。 参考资料： https://www.zhihu.com/question/19578734 https://www.google.com/fonts/","categories":[{"name":"front-end","slug":"front-end","permalink":"http://vestin.github.io/categories/front-end/"}],"tags":[{"name":"front-end","slug":"front-end","permalink":"http://vestin.github.io/tags/front-end/"}]},{"title":"atom useage","slug":"atom-useage","date":"2016-04-19T05:29:24.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/19/atom-useage/","link":"","permalink":"http://vestin.github.io/2016/04/19/atom-useage/","excerpt":"#Install Package 国内安装非常慢，通常使用手动安装 手动安装方法一： cd ~/.atom/packages git clone https://github.com/atom/vim-mode.git cd vim-mode npm install","text":"#Install Package 国内安装非常慢，通常使用手动安装 手动安装方法一： cd ~/.atom/packages git clone https://github.com/atom/vim-mode.git cd vim-mode npm install 手动安装方法二： apm install atom/vim-mode #Keybindings vim-mode keybindingspath: ~/.atom/packages/vim-mode/keymaps/vim-mode.cson","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"RPC-http","slug":"RPC-http","date":"2016-04-19T03:10:42.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/19/RPC-http/","link":"","permalink":"http://vestin.github.io/2016/04/19/RPC-http/","excerpt":"[TOC] RPC是什么PRC(Remote Procedure Call 远程过程调用) 是本地计算机程序通过网络调用远程计算机服务。","text":"[TOC] RPC是什么PRC(Remote Procedure Call 远程过程调用) 是本地计算机程序通过网络调用远程计算机服务。 为什么要用RPC 可以做到分布式，现代化的微服务 部署灵活 解耦服务 扩展性强 RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。 RPC结构client-server 结构，调用方为client，远程被调用方为server。 RPC工作原理1.调用客户端句柄；执行传送参数2.调用本地系统内核发送网络消息3.消息传送到远程主机4.服务器句柄得到消息并取得参数5.执行远程过程6.执行的过程将结果返回服务器句柄7.服务器句柄返回结果，调用远程系统内核8.消息传回本地主机9.客户句柄由内核接收消息10.客户接收句柄返回的数据 RPC框架有哪些一般主流框架都实现了跨平台跨语言的C/S RPC调用。 dubbo,主流配合hessian协议使用,duboo/hessian. DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。 thrift,Apache Thrift software framework The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages. hprose,High Performance Remote Object Service Engine 是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。 RPC-HTTPHTTP 本质来讲是RPC调用的一种实现方式。换种方式说，RPC客户端可以通过HTTP连接到RPC服务端程序执行RPC(远程过程调用)。 把RPC比作交通工具，那么HTTP就是相当于汽车 HTTP 调用优点 协议统一，各个平台几乎都原生支持HTTP 调用简单,直接 开发方便 HTTP（HyperText Transfer Protocol）是应用层通信协议, HTTP 的缺点是协议头较重，一般请求到具体服务器的链路较长，可能会有 DNS 解析、Nginx 代理等。 RPC 框架的优点 RPC框架一般使用长链接，不必每次通信都要3次握手，减少网络开销 RPC框架一般都有注册中心，有丰富的监控管理 发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作 协议私密，安全性较高 rpc 协议更简单内容更小，效率更高 服务化架构、服务化治理，RPC框架是一个强力的支撑 RPC-RESTREST 是定义http接口调用的一种方式，REST 也可以说是RPC调用的实现方式。 phprpc解决方案 hprose phprpc office website yar(yet another RPC framework) github 为什么需要RPC，而不是简单的HTTP接口 (oschina) RPC调用框架比较分析 RPC框架几行代码就够了 支撑微博千亿调用的轻量级RPC框架：Motan","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://vestin.github.io/tags/RPC/"},{"name":"http","slug":"http","permalink":"http://vestin.github.io/tags/http/"},{"name":"php","slug":"php","permalink":"http://vestin.github.io/tags/php/"}]},{"title":"factory pattern","slug":"design-pattern-factory-pattern","date":"2016-04-18T09:46:58.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/18/design-pattern-factory-pattern/","link":"","permalink":"http://vestin.github.io/2016/04/18/design-pattern-factory-pattern/","excerpt":"工厂模式(Factory Pattern)[TOC] 工厂模式是最重要的模式，因为大多数模式都需要用到工厂模式。如果不能正确的运用工厂模式，那么可以说无法成为合格的架构师。多数设计模式的内容讲解的都是如何设计接口。接口如何产生呢？如果在客户代码（类库的使用者称之为客户）中直接使用具体类，那么就失去了接口的意义。因为接口的使用目的，就是要降低客户对具体类的依赖程度。如果在客户代码中直接使用接口，那么就造成了客户对具体类名称的依赖。（客户最终需要以某种方式指明所需要的具体类，如配置文件或代码，但是只需要指出一次，所以说降低对具体类的依赖程度）。要使客户代码不依赖具体类，唯一的方法，就是让客户代码不依赖具体类的部分不知道具体类的名称。知道具体类名称的部分，仅仅是配置部分。（配置文件或者配置代码）。依赖不可能完全消除，除非二者毫无联系。但是可以将这种依赖的程度降到最低。既然不能直接创建具体类，那么就需要通过一个创建者类来创建接口的实现类。这样就产生了工厂类。","text":"工厂模式(Factory Pattern)[TOC] 工厂模式是最重要的模式，因为大多数模式都需要用到工厂模式。如果不能正确的运用工厂模式，那么可以说无法成为合格的架构师。多数设计模式的内容讲解的都是如何设计接口。接口如何产生呢？如果在客户代码（类库的使用者称之为客户）中直接使用具体类，那么就失去了接口的意义。因为接口的使用目的，就是要降低客户对具体类的依赖程度。如果在客户代码中直接使用接口，那么就造成了客户对具体类名称的依赖。（客户最终需要以某种方式指明所需要的具体类，如配置文件或代码，但是只需要指出一次，所以说降低对具体类的依赖程度）。要使客户代码不依赖具体类，唯一的方法，就是让客户代码不依赖具体类的部分不知道具体类的名称。知道具体类名称的部分，仅仅是配置部分。（配置文件或者配置代码）。依赖不可能完全消除，除非二者毫无联系。但是可以将这种依赖的程度降到最低。既然不能直接创建具体类，那么就需要通过一个创建者类来创建接口的实现类。这样就产生了工厂类。 简单工厂模式 工厂模式 简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式 简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 Static Factory Pattern simple factory pattern Static Factory Pattern UMP map 角色分工： 工厂（Creator）角色 简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。 抽象产品（Product）角色 简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品（Concrete Product）角色 是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。简单工厂模式的优缺点分析： 优点： 有利于系统优化 工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。 缺点： 违反了单一职责原则(SRP),开放-封闭原则(OCP) 由于工厂类集中了所有实例的创建逻辑，这就直接导致一旦这个工厂出了问题，所有的客户端都会受到牵连；而且由于简单工厂模式的产品室基于一个共同的抽象类或者接口，这样一来，但产品的种类增加的时候，即有不同的产品接口或者抽象类的时候，工厂类就需要判断何时创建何种种类的产品，这就和创建何种种类产品的产品相互混淆在了一起，违背了单一职责，导致系统丧失灵活性和可维护性。而且更重要的是，简单工厂模式违背了“开放封闭原则”，就是违背了“系统对扩展开放，对修改关闭”的原则，因为当我新增加一个产品的时候必须修改工厂类，相应的工厂类就需要重新编译一遍。 123456789101112131415161718192021222324252627282930313233343536//抽象产品interface Car&#123; abstract public run();&#125;//具体产品Class Jeep&#123; public function run()&#123; echo &apos;Jeep&apos;; &#125;&#125;Class BMW&#123; public function run()&#123; echo &apos;BMW&apos;; &#125;&#125;//简单工厂Class SimpleCarFactory&#123; static public createCar(type)&#123; switch(type)&#123; case 1: return new Jeep; case 2: return new BMW; &#125; &#125;&#125;//test$car = SimpleCarFactory::createCar(1);$car-&gt;run(); //Jeep$car = SimpleCarFactory::createCar(2);$car-&gt;run(); //BMW 工厂模式 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。在同一等级(产品)结构中，支持增加任意产品。 factory-pattern-image 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//汽车产品interface Car&#123; public function run();&#125;//具体产品jeepClass Jeep implements Car&#123; public function run()&#123; echo &apos;jeep run...&apos;; &#125;&#125;//具体产品BMWClass BMW implements Car&#123; public function run()&#123; echo &apos;BMW run...&apos;; &#125;&#125;//工厂抽象abstract Class CarFactory&#123; abstract public function createCar();&#125;//Jeep 工厂Class JeepCarFactory&#123; public function createCar()&#123; return new Jeep; &#125;&#125;//BMW 工厂Class BMWCarFactory&#123; public function createCar()&#123; return new BMW; &#125;&#125;//Client$factory = new JeepCarFactory;$car = $factory-&gt;createCar();$car-&gt;run(); //jeep run...$factory = new BMWCarFactory;$car = $factory-&gt;createCar();$car-&gt;run(); //bmw run... 抽象工厂 抽象工厂是应对产品族概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。应对产品族概念而生，增加新的产品线很容易，但是无法增加新的产品。 abstract factory pattern 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//抽象车interface Car&#123; public function run();&#125;//抽象自行车interface Bike&#123; public function run();&#125;//Jeep车Class Jeep implements Car&#123; public function run()&#123; echo &apos;Jeep run...&apos;.PHP_EOL; &#125;&#125;//Jeep自行车Class JeepBike implements Bike&#123; public function run()&#123; echo &apos;JeepBiked run...&apos;.PHP_EOL; &#125;&#125;//BMW车Class BMW implements Car&#123; public function run()&#123; echo &apos;BMW run..&apos;.PHP_EOL; &#125;&#125;//BMW自行车Class BMWBike implements Bike&#123; public function run()&#123; echo &apos;BMWBike run..&apos;.PHP_EOL; &#125;&#125;//抽象交通工具生产工厂interface Vehicle&#123; public function createCar(); public function createBike();&#125;//Jeep 工厂Class JeepFactory implements Vehicle&#123; public function createCar()&#123; return new Jeep; &#125; public function createBike()&#123; return new JeepBike; &#125;&#125;//BMW 工厂Class BMWFactory implements Vehicle&#123; public function createCar()&#123; return new BMW; &#125; public function createBike()&#123; return new BMWBike; &#125;&#125;//Client$factory = new JeepFactory;$car = $factory-&gt;createCar();$bike = $factory-&gt;createBike();$car-&gt;run();$bike-&gt;run();$factory = new BMWFactory;$car = $factory-&gt;createCar();$bike = $factory-&gt;createBike();$car-&gt;run();$bike-&gt;run(); 简单工厂模式、工厂模式、抽象工厂模式的差别 可以参考文章三种工厂模式的差别 简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力） 工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 以上三种工厂 方法在等级结构和产品族这两个方向上的支持程度不同。所以要根据情况考虑应该使用哪种方法。 简单工厂，一般是两级结构。工厂类创建接口。随着接口创建复杂性的增强，可能在接口创建的过程中，一个创建者类，无法承担创建所有的接口类的职责。可能会有这样的情况，我们定义了一个接口，有6个实现类分别是123456号。但是，这六个实现类不可能用一个工厂创建出来，因为123号是windows下的实现，而456号是linux上的实现。（假设我们使用的语言不是广大人民群众热爱的java语言），那么这个时候，我还需要客户方用相同的方式来创建这个借口，而不是在代码中到处写 1234567Java代码 :if (操作系统==&quot;windows&quot;);&#123; ... &#125; else&#123; ... &#125; 那样就太麻烦了。设计模式就是为了减少麻烦，而不是什么别的废话，比如什么太极八卦、天人合一、面向xx之类的。因为怕麻烦，所以搞出设计模式这个咚咚减少麻烦。如果你发现用了设计模式更麻烦了，那么肯定是你用错了。这个时候为了省事，我就把工厂也抽象成一个接口（因为我有两个相似的工厂，如果只有一个，我还废话什么呢），这样就成了工厂方法。当然，既然工厂方法成了一个接口，那么当然也需要用一个工厂来创建它。这个时候，创建是三级结构，简单工厂（此时是工厂的工厂）创建工厂接口（本来是个类，现在因为进一步的抽象，成为接口了），工厂接口创建产品。过了一段时间，随着我们的工厂业务不断发展，我们有了很多产品。比如，我们有锤子和钉子两种产品。这两种产品都有windows品牌和linux品牌的。我们给锤子和钉子各自定义了一个创建的接口。 1234567Java代码 :interface 锤子工厂&#123; 造锤子（）； &#125; interface 钉子工厂&#123; 造钉子();; &#125; 可是，我们发现某些用户，用windows的锤子去敲linux的钉子，从而把程序敲出了bug。这当然是我们的错误，因为我们违反了一条金科玉律：要想使你的程序稳定运行，你假设用户是猪。所以，我们把锤子和钉子的工厂合并，让一个工厂只能造出配套的锤子和钉子，这样猪就没有犯错误的机会了。于是我们搞出一个抽象工厂：1234interface 铁匠铺&#123;造锤子（）；造钉子();&#125; 当然，这个铁匠铺是个接口，所以同样需要用一个工厂来创建它。所以，这个时候，工厂还是三级结构。我们的工厂，业务很多，而且产品一般都是配套使用的（这样可以多骗点钱），所以，我们大多数情况下，都是使用抽象工厂和简单工厂。简单工厂用来创建工厂，抽象工厂创建产品。工厂的作用，就是创建接口。其实我们不知道什么是设计模式，我们只是怕麻烦。什么是麻烦呢？我们觉得把同样的代码写两遍就非常麻烦。所以，我们宁可多写几句，也要解决麻烦。猪不怕麻烦，可以日复一日的重复相同的事情，可是我们不是猪。 参考文章 http://www.cnblogs.com/jy02414216/archive/2012/08/10/2633084.html http://blog.csdn.net/superbeck/article/details/4446177 http://blog.chinaunix.net/uid-25958655-id-4243289.html http://wxg6203.iteye.com/blog/740229","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"decorator pattern","slug":"design-pattern-decorator-pattern","date":"2016-04-18T09:43:59.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/18/design-pattern-decorator-pattern/","link":"","permalink":"http://vestin.github.io/2016/04/18/design-pattern-decorator-pattern/","excerpt":"装饰模式(Decorator Pattern) 装饰模式 动态的将责任附加到对象上。 装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，页就是装饰来包裹真实的对象。","text":"装饰模式(Decorator Pattern) 装饰模式 动态的将责任附加到对象上。 装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，页就是装饰来包裹真实的对象。 Decorator Pattern Decorator Pattern UMP map More Detail 装饰模式优点 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。 避免在层次结构高层的类有太多的特征 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 装饰模式的缺点 使用装饰模式会产生比使用继承关系更多的对象 对象很像，排查错误比较困难 主题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpabstract class Beverage&#123; public $_name; abstract public function Cost();&#125;// 被装饰者类class Coffee extends Beverage&#123; public function __construct()&#123; $this-&gt;_name = &apos;Coffee&apos;; &#125; public function Cost()&#123; return 1.00; &#125;&#125;// 以下三个类是装饰者相关类class CondimentDecorator extends Beverage&#123; public function __construct()&#123; $this-&gt;_name = &apos;Condiment&apos;; &#125; public function Cost()&#123; return 0.1; &#125;&#125;class Milk extends CondimentDecorator&#123; public $_beverage; public function __construct($beverage)&#123; $this-&gt;_name = &apos;Milk&apos;; if($beverage instanceof Beverage)&#123; $this-&gt;_beverage = $beverage; &#125;else exit(&apos;Failure&apos;); &#125; public function Cost()&#123; return $this-&gt;_beverage-&gt;Cost() + 0.2; &#125;&#125;class Sugar extends CondimentDecorator&#123; public $_beverage; public function __construct($beverage)&#123; $this-&gt;_name = &apos;Sugar&apos;; if($beverage instanceof Beverage)&#123; $this-&gt;_beverage = $beverage; &#125;else&#123; exit(&apos;Failure&apos;); &#125; &#125; public function Cost()&#123; return $this-&gt;_beverage-&gt;Cost() + 0.2; &#125;&#125;// Test Case//1.拿杯咖啡$coffee = new Coffee();//2.加点牛奶$coffee = new Milk($coffee);//3.加点糖$coffee = new Sugar($coffee);printf(&quot;Coffee Total:%0.2f元\\n&quot;,$coffee-&gt;Cost());","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"Publish/Subscribe Pattern","slug":"design-pattern-Publish-Subscribe","date":"2016-04-18T06:46:20.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/18/design-pattern-Publish-Subscribe/","link":"","permalink":"http://vestin.github.io/2016/04/18/design-pattern-Publish-Subscribe/","excerpt":"观察者模式 观察者模式 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它所有依赖者都会收到通知并自动更新。","text":"观察者模式 观察者模式 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它所有依赖者都会收到通知并自动更新。 subject observer subject observer UMP map In php 主题12345678910111213141516171819202122232425262728293031323334353637&lt;?php//被订阅的主题interface subject &#123; //注册的观察者 private $observers = []; /** * Observer $observer * * return void */ public function rigisterObserver(Observer $observer)&#123; $this-&gt;observers[] = $observer; &#125; /** * Observer $observer * * return void */ public function removeObserver(Observer $observer)&#123; unset($this-&gt;observers[array_search($observer)]); &#125; /** * Notify all observer * * return void */ public function notifyObservers()&#123; foreach($this-&gt;observers as $observer)&#123; $observer-&gt;update(); &#125; &#125;&#125; 观察者123456789&lt;?php//观察者interface Observer&#123; /** * Do things when notify */ abstract public function update();&#125;","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"design-pattern-principle","slug":"design-pattern-principle","date":"2016-04-18T06:36:28.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/18/design-pattern-principle/","link":"","permalink":"http://vestin.github.io/2016/04/18/design-pattern-principle/","excerpt":"design-pattern##设计原则 封装变化。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 为交互对象之间的松耦合设计而努力。 开放-关闭原则（对扩展开放，对修改关闭）。","text":"design-pattern##设计原则 封装变化。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 为交互对象之间的松耦合设计而努力。 开放-关闭原则（对扩展开放，对修改关闭）。 依赖倒置原则（要依赖抽象，不要依赖具体类）。指导方针，帮助避免违反依赖倒置原则： 变量不可以持有具体类的引用。 不要让类派生自具体类。 不要覆盖基类中已实现的方法。 最少知识原则（Least Knowledge,只和朋友交谈)。就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法： 该对象本身 被当作方法的参数而传递进来的对象 此方法所创建或实例化的任何对象 对象的任何组件 Hollywood principle：”Don’t call me; I’ll call you.” read more 单一职责原则（Single responsibility principle）（一个类应该只有一个引起变化的原因） 依赖倒置原则依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 理性怀疑原则模式本身非常有用，但是应该将他们用作一种思考问题的手段，而不是解决问题的处方。注意在使用模式的时候出现以下问题 错误 原因 浮于表面 仅仅对低层情况有了一些肤浅的理解，就草草选择一个模式 偏见 对模式过于偏信。根据已经选定的模式/模型来解释所有数据，不愿意对自己的偏见有任何质疑 错选 不理解模式的适用背景和条件（对模式的分类关系理解不全），选择了错误的模式 削足适履 忽略了实际的、具体的实例行为中的例外情况，不符合模式中所表达的理论。建模出的对象过于僵硬，不符合实际情况 模式实现的具体方式应该由问题的本质、约束条件和需求等等决定，而不是根据你在某本模式书中碰巧看到的某个实现。","categories":[{"name":"coding","slug":"coding","permalink":"http://vestin.github.io/categories/coding/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://vestin.github.io/tags/design-pattern/"}]},{"title":"markdown language","slug":"markdown-language","date":"2016-04-18T05:44:59.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/18/markdown-language/","link":"","permalink":"http://vestin.github.io/2016/04/18/markdown-language/","excerpt":"目录 (Table of Contents) [TOC]","text":"目录 (Table of Contents) [TOC] Heading 1Heading 2Heading 3Heading 4Heading 5Heading 6Heading 1 link Heading linkHeading 2 link Heading linkHeading 3 link Heading linkHeading 4 link Heading link Heading link Heading linkHeading 5 link Heading linkHeading 6 link Heading link标题（用底线的形式）Heading (underline)This is an H1This is an H2字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 123456789101112131415161718192021222324252627282930313233343536function test() &#123; console.log(\"Hello world!\");&#125;(function()&#123; var box = function() &#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log('box.init()'); return this; &#125;, add : function(str) &#123; alert(\"add\", str); return this; &#125;, remove : function(str) &#123; alert(\"remove\", str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add(\"jQuery\").remove(\"jQuery\"); HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=\"utf-8\" /&gt; &lt;meta name=\"keywords\" content=\"Editor.md, Markdown, Editor\" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=\"text/css\"&gt; body&#123;font-size:14px;color:#444;font-family: \"Microsoft Yahei\", Tahoma, \"Hiragino Sans GB\", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"text-xxl\"&gt;Hello world!&lt;/h1&gt; &lt;p class=\"text-green\"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片 ImagesImage: Follow your heart. 图为：厦门白城沙滩 图片加链接 (Image + Link)： [ 李健首张专辑《似水流年》封面 图为：李健首张专辑《似水流年》封面 列表 Lists无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes© &amp; ¨ ™ ¡ £&amp; &lt; &gt; ¥ € ® ± ¶ § ¦ ¯ « · X² Y³ ¾ ¼ × ÷ » 18ºC “ &apos; [========] Emoji表情 :smiley: Blockquotes :star: GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: :smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; :smiley: this is an incomplete item test link :fa-star: :fa-gear:; :smiley: this is :fa-star: :fa-gear: an incomplete item test link; 反斜杠 Escape*literal asterisks* [========] 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$x &gt; y$$ $$(\\sqrt{3x-1}+(1+x)^2)$$ $$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$ 多行公式： 12345\\displaystyle\\left( \\sum\\_&#123;k=1&#125;^n a\\_k b\\_k \\right)^2\\leq\\left( \\sum\\_&#123;k=1&#125;^n a\\_k^2 \\right)\\left( \\sum\\_&#123;k=1&#125;^n b\\_k^2 \\right) 123456789\\displaystyle \\frac&#123;1&#125;&#123; \\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123; \\frac25 \\pi&#125;&#125; = 1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123; 1+\\frac&#123;e^&#123;-6\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\cdots&#125; &#125; &#125; &#125; 123f(x) = \\int_&#123;-\\infty&#125;^\\infty \\hat f(\\xi)\\,e^&#123;2 \\pi i \\xi x&#125; \\,d\\xi 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op [========] 绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says HelloNote right of China: China thinks\\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks! End","categories":[{"name":"tools","slug":"tools","permalink":"http://vestin.github.io/categories/tools/"}],"tags":[{"name":"work tools","slug":"work-tools","permalink":"http://vestin.github.io/tags/work-tools/"}]},{"title":"ubuntu 系统安装后必做","slug":"ubuntu-install","date":"2016-04-18T05:30:36.000Z","updated":"2017-10-19T08:44:29.055Z","comments":true,"path":"2016/04/18/ubuntu-install/","link":"","permalink":"http://vestin.github.io/2016/04/18/ubuntu-install/","excerpt":"ubuntu 安装2015-10-14 14:46:28 星期三 @vestin 系统安装 下载 image writer 镜像写入工具 下载 ubuntu 最新系统 ubuntu 下载 写入镜像 安装","text":"ubuntu 安装2015-10-14 14:46:28 星期三 @vestin 系统安装 下载 image writer 镜像写入工具 下载 ubuntu 最新系统 ubuntu 下载 写入镜像 安装 系统设置 root 用户添加 sudo passwd root su 外观 主题：Radiance 行为：开启工作区 软件和更新 附加驱动：使用附加驱动 更新：每周 时间和日期 时钟：星期，日期，年份，月历 用户账户 在菜单栏显示登录名 拒绝GUEST帐号登录 1sudo sh -c &apos;printf &quot;[SeatDefaults]\\nallow-guest=false\\n&quot; &gt;/usr/share/lightdm/lightdm.conf.d/50-no-guest.conf&apos; 链接到windows的WORKGROUP gedit /etc/samba/smb.conf workgroup = WORKGROUP netbios name = something 文件管理器CRTL+L 输入 smb://xxx.xxx.xxx.xxx/ 链接 工具安装 su filezilla apt-get install filezilla vim apt-get install vim 天涯vpn配置 网络链接-&gt;vpn-&gt;配置vpn网关:us5.tyvpn.cn高级:身份验证(MSCHAP,MSCHAP2) 安全(MMPE) chorme 登录 shadowsocks-qt5 123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 qt5 配置 配置服务器IP:运营部可使用以下两个(建议使用不同的)173.254.200.25173.254.200.26技术部可以使用以下三个173.254.200.34173.254.200.25173.254.200.18密码:Ya*加密:aes-256-cfb(默认，无需改动)备注:无关紧要，自己填写代理端口:1080(默认，无需改动) 邮件客户端thunderbird 配置 网易企业客户端配置接受 imap.ym.163.com 993 ssl/tls 普通密码发送 smtp.ym.163.com 465 ssl/tls 普通密码 phpstorm 安装 apt-get install default-jre 下载phpstorm9.0 到 /myfile 解压，移动到 /usr/share ,创建软链接到/usr/bin 中 启动，锁定到任务栏 User Name: newasp123456===== LICENSE BEGIN =====14617-1204201000001xrVkhnPuM!Bd!vYtgydcusnqtmM!hZWoGg&quot;DprWxZCBwsy8T91O7MRuNVHtrbzv8O9mmoLvtijcHSSE7i5Jr!===== LICENSE END ===== sublime 安装配置 sublime3 dpkg -i .deb 配置 unity tool 工具设置 sudo apt-get install unity-tweak-tool dash 中打开unity-tweak-tool conky 系统监视 sudo apt-get install conky 工作环境安装 apt-get install php5 apt-get install mysql-server apt-get install mysql-client apt-get install php5-mysql apt-get install php5-xdebug apache2 配置 php5 配置 安装 git 5 axel、aria 多线程下载。axel -n 10 下载url， 开10线程下载文件百度云的东西可以用axel下载，我经常在服务器用axel下载百度云的东西。 Top Things To Do After Installing Ubuntu 15.04","categories":[{"name":"linux","slug":"linux","permalink":"http://vestin.github.io/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://vestin.github.io/tags/ubuntu/"}]}]}